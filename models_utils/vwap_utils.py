from copy import deepcopy

import numpy as np
import pandas as pd

# get_intervals_list() from profile_utils
def get_periods_list(df: pd.DataFrame, interval: pd.Timedelta | pd.DateOffset):
    first_date = df['datetime'].iat[0].normalize() # any datetime to 00:00:00
    first_interval_date = first_date + interval
    first_interval_df = df[df['datetime'] < first_interval_date]

    df_list = [first_interval_df]

    last_date = df['datetime'].tail(1).values[0]
    current_date = first_interval_date
    while current_date < last_date:
        start_interval_date = current_date
        end_interval_date = start_interval_date + interval
        interval_df = df.loc[(df['datetime'] >= start_interval_date) & (df['datetime'] < end_interval_date)]

        df_list.append(interval_df)
        current_date = end_interval_date

    return df_list

# Logic generated by LLM
# Modified for multiples bands

# VWAP + StdDev Bands
def stddev_bands(price, vwap, multipliers: tuple = (1.236, 2.382, 3.618)):
    stddev = np.zeros(len(price))
    for i in range(len(price)):
        diff = price[:i + 1] - vwap[i]
        variance = np.sum(diff ** 2) / max(i, 1)
        stddev[i] = np.sqrt(variance)

    return _build_bands(vwap, stddev, multipliers)

# VWAP + StdDev => Volume Weighted Bands
def stddev_bands_volume(price, vwap, volume, multipliers: tuple = (1.236, 2.382, 3.618)):
    vw_stddev = np.zeros(len(price))
    for i in range(len(price)):
        diff = price[:i + 1] - vwap[i]
        weighted = diff ** 2 * volume[:i + 1]
        vw_stddev[i] = np.sqrt(weighted.sum() / volume[:i + 1].sum())

    return _build_bands(vwap, vw_stddev, multipliers)

def _build_bands(vwap, stddev, multipliers):
    upper_1 = vwap + multipliers[0] * stddev
    upper_2 = vwap + multipliers[1] * stddev
    upper_3 = vwap + multipliers[2] * stddev

    lower_1 = vwap - multipliers[0] * stddev
    lower_2 = vwap - multipliers[1] * stddev
    lower_3 = vwap - multipliers[2] * stddev

    return upper_1, upper_2, upper_3, lower_1, lower_2, lower_3


# VWAP => Quantile Bands
def quantile_bands(price, vwap, quantiles=(0.7, 0.85, 0.95)):
    dist = np.abs(price - vwap)
    bands = {q: np.zeros(len(price)) for q in quantiles}

    for i in range(len(price)):
        window = dist[:i + 1]
        for q in quantiles:
            bands[q][i] = np.quantile(window, q)

    bands_list = [(bands[key]) for key in bands.keys()]
    return _build_bands_quantile(vwap, bands_list)

# VWAP => Quantile => Volume Weighted Bands
def quantile_bands_volume(price, vwap, volume, quantiles=(0.7, 0.85, 0.95)):
    dist = np.abs(price - vwap)
    bands = {q: np.zeros(len(price)) for q in quantiles}

    for i in range(len(price)):
        window_dist = dist[:i + 1]
        window_vol  = volume[:i + 1]

        for q in quantiles:
            bands[q][i] = _weighted_quantile(window_dist, window_vol, q)

    bands_list = [(bands[key]) for key in bands.keys()]
    return _build_bands_quantile(vwap, bands_list)

def _build_bands_quantile(vwap, width):
    upper_1 = vwap + width[0]
    upper_2 = vwap + width[1]
    upper_3 = vwap + width[2]

    lower_1 = vwap - width[0]
    lower_2 = vwap - width[1]
    lower_3 = vwap - width[2]

    return upper_1, upper_2, upper_3, lower_1, lower_2, lower_3


# VWAP => Quantile Asymmetric Bands
def quantile_asymmetric_bands(price, vwap, q_up=(0.7, 0.85, 0.95), q_down=(0.7, 0.85, 0.95)):
    upper_1, upper_2, upper_3 = (deepcopy(np.zeros(len(price))) for _ in range(3))
    lower_1, lower_2, lower_3 = (deepcopy(np.zeros(len(price))) for _ in range(3))

    for i in range(len(price)):
        diff = price[:i + 1] - vwap[i]

        # Positive side (above VWAP)
        pos = diff[diff > 0]
        if len(pos) > 0:
            upper_1[i] = vwap[i] + np.quantile(pos, q_up[0])
            upper_2[i] = vwap[i] + np.quantile(pos, q_up[1])
            upper_3[i] = vwap[i] + np.quantile(pos, q_up[2])
        else:
            upper_1[i] = vwap[i]
            upper_2[i] = vwap[i]
            upper_3[i] = vwap[i]

        # Negative side (below VWAP)
        neg = -diff[diff < 0]  # flip to positive distances
        if len(neg) > 0:
            lower_1[i] = vwap[i] - np.quantile(neg, q_down[0])
            lower_2[i] = vwap[i] - np.quantile(neg, q_down[1])
            lower_3[i] = vwap[i] - np.quantile(neg, q_down[2])
        else:
            lower_1[i] = vwap[i]
            lower_2[i] = vwap[i]
            lower_3[i] = vwap[i]

    return upper_1, upper_2, upper_3, lower_1, lower_2, lower_3

# VWAP => Quantile Asymmetric => Volume Weighted Bands
def quantile_asymmetric_bands_volume(price, vwap, volume, q_up=(0.7, 0.85, 0.95), q_down=(0.7, 0.85, 0.95)):
    upper_1, upper_2, upper_3 = (deepcopy(np.zeros(len(price))) for _ in range(3))
    lower_1, lower_2, lower_3 = (deepcopy(np.zeros(len(price))) for _ in range(3))

    for i in range(len(price)):
        diff = price[:i + 1] - vwap[i]
        vol = volume[:i + 1]

        # ----- Upper side (price > VWAP) -----
        mask_up = diff > 0
        pos = diff[mask_up]
        w_up = vol[mask_up]

        if len(pos) > 0:
            q1_val = _weighted_quantile(pos, w_up, q_up[0])
            q2_val = _weighted_quantile(pos, w_up, q_up[1])
            q3_val = _weighted_quantile(pos, w_up, q_up[2])
            upper_1[i] = vwap[i] + q1_val
            upper_2[i] = vwap[i] + q2_val
            upper_3[i] = vwap[i] + q3_val
        else:
            upper_1[i] = vwap[i]
            upper_2[i] = vwap[i]
            upper_3[i] = vwap[i]

        # ----- Lower side (price < VWAP) -----
        mask_dn = diff < 0
        neg = -diff[mask_dn]  # flip to positive distances
        w_dn = vol[mask_dn]

        if len(neg) > 0:
            q1_val = _weighted_quantile(neg, w_dn, q_down[0])
            q2_val = _weighted_quantile(neg, w_dn, q_down[1])
            q3_val = _weighted_quantile(neg, w_dn, q_down[2])
            lower_1[i] = vwap[i] - q1_val
            lower_2[i] = vwap[i] - q2_val
            lower_3[i] = vwap[i] - q3_val
        else:
            lower_1[i] = vwap[i]
            lower_2[i] = vwap[i]
            lower_3[i] = vwap[i]

    return upper_1, upper_2, upper_3, lower_1, lower_2, lower_3

def _weighted_quantile(values, weights, q):
    """
    values  : positive distances
    weights : corresponding volumes
    q       : quantile in [0, 1]
    """
    if len(values) == 0:
        return 0.0

    sorter = np.argsort(values)
    values = values[sorter]
    weights = weights[sorter]

    cum_weights = np.cumsum(weights)
    cutoff = q * cum_weights[-1]

    return values[np.searchsorted(cum_weights, cutoff)]