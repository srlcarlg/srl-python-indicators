import numpy as np

from models_utils.odf_models import UltraBubblesBreak, BubblesFilter


def touches_spikes(o, h, l, c, top, bottom):
    # If any OHLC inside rectangle
    if (o >= bottom and o <= top) or \
            (h >= bottom and h <= top) or \
            (l >= bottom and l <= top) or \
            (c >= bottom and c <= top):
        return True

    # If bar fully crosses rectangle (high above and low below)
    if h > top and l < bottom:
        return True
    return False


def touches_bubbles(b: BubblesFilter, o, h, l, c, top, bottom):
    if b.break_at == UltraBubblesBreak.Close_Only or b.break_at == UltraBubblesBreak.Close_plus_BarBody:
        if o >= bottom and o <= top:
            return True
        # If bar fully crosses rectangle (high above and low below)
        if b.break_at == UltraBubblesBreak.Close_plus_BarBody:
            if h > top and l < bottom:
                return True
    elif b.break_at == UltraBubblesBreak.OHLC_plus_BarBody:
        # If any OHLC inside rectangle
        if (o >= bottom and o <= top) or \
                (h >= bottom and h <= top) or \
                (l >= bottom and l <= top) or \
                (c >= bottom and c <= top):
            return True

        # If bar fully crosses rectangle (high above and low below)
        if h > top and l < bottom:
            return True

    return False

# functions generated by LLM
# after some prompt pain
def rolling_percentile(a):
    # Percentile Rank of last element inside window
    last = a[-1]
    return np.mean(a <= last) * 100

def power_softmax(window_values, alpha=1):
    # Softmax with Temperature
    w = np.maximum(window_values, 1e-12)
    p = np.power(w, alpha)
    s = p / p.sum()
    return s[-1]
def power_softmax_profile(window_values, alpha=1):
    w = np.maximum(window_values, 1e-12)
    p = np.power(w, alpha)
    s = p / p.sum()
    return s

def l1norm(window_values):
    denom = np.abs(window_values).sum()
    return window_values[-1] / denom if denom != 0 else 1
def l1norm_profile(window_values):
    denom = np.abs(window_values).sum()
    return window_values / denom if denom != 0 else 1

def l2norm(window_values):
    denom = np.sqrt((window_values ** 2).sum())
    return window_values[-1] / denom if denom != 0 else 0.0
